# # # # # # # # # # # # # # # # # # # # # # #
# Homework 1
# Problem 2: Recognising digits
# Author: Marcus Hansen
# Course: FFR135 Artificial Neural Networks
# # # # # # # # # # # # # # # # # # # # # # #

import numpy as np
import matplotlib.pyplot as plt
import sys

np.set_printoptions(threshold=sys.maxsize)

# Function to convert to a numpy array.
def listToArray(list: list) -> np.array:
    return np.array(list).reshape(-1)

# Function to compute the weightMatrix by hebbs_rule
def hebbsRule(neurons: int, patterns: np.array) -> np.array:
    weightMatrix = np.zeros((neurons, neurons))
    for i in range(len(patterns)):
        outerProduct = np.outer(patterns[i, :].reshape(1, -1), patterns[i, :])
        weightMatrix = weightMatrix + outerProduct

    # Normalize by N and set all self coupling to zero
    weightMatrix = weightMatrix / neurons
    weightMatrix[np.diag_indices_from(weightMatrix)] = 0

    return weightMatrix


# Pattern representation
x1 = listToArray(
    [[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1],
     [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1], [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1], [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1],
     [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1], [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1], [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1],
     [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1], [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1], [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1],
     [-1, 1, 1, 1, -1, -1, 1, 1, 1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1],
     [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]])

x2 = listToArray(
    [[-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1],
     [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1],
     [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1],
     [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1],
     [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1], [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1],
     [-1, -1, -1, 1, 1, 1, 1, -1, -1, -1]])

x3 = listToArray(
    [[1, 1, 1, 1, 1, 1, 1, 1, -1, -1], [1, 1, 1, 1, 1, 1, 1, 1, -1, -1], [-1, -1, -1, -1, -1, 1, 1, 1, -1, -1],
     [-1, -1, -1, -1, -1, 1, 1, 1, -1, -1], [-1, -1, -1, -1, -1, 1, 1, 1, -1, -1],
     [-1, -1, -1, -1, -1, 1, 1, 1, -1, -1], [-1, -1, -1, -1, -1, 1, 1, 1, -1, -1], [1, 1, 1, 1, 1, 1, 1, 1, -1, -1],
     [1, 1, 1, 1, 1, 1, 1, 1, -1, -1], [1, 1, 1, -1, -1, -1, -1, -1, -1, -1], [1, 1, 1, -1, -1, -1, -1, -1, -1, -1],
     [1, 1, 1, -1, -1, -1, -1, -1, -1, -1], [1, 1, 1, -1, -1, -1, -1, -1, -1, -1],
     [1, 1, 1, -1, -1, -1, -1, -1, -1, -1], [1, 1, 1, 1, 1, 1, 1, 1, -1, -1], [1, 1, 1, 1, 1, 1, 1, 1, -1, -1]])

x4 = listToArray(
    [[-1, -1, 1, 1, 1, 1, 1, 1, -1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1],
     [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, 1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1]])

x5 = listToArray(
    [[-1, 1, 1, -1, -1, -1, -1, 1, 1, -1], [-1, 1, 1, -1, -1, -1, -1, 1, 1, -1], [-1, 1, 1, -1, -1, -1, -1, 1, 1, -1],
     [-1, 1, 1, -1, -1, -1, -1, 1, 1, -1], [-1, 1, 1, -1, -1, -1, -1, 1, 1, -1], [-1, 1, 1, -1, -1, -1, -1, 1, 1, -1],
     [-1, 1, 1, -1, -1, -1, -1, 1, 1, -1], [-1, 1, 1, 1, 1, 1, 1, 1, 1, -1], [-1, 1, 1, 1, 1, 1, 1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, -1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, -1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, -1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, -1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, -1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, -1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, -1, 1, 1, -1]])

# Store the digits in a Hopfield network using Hebb's rule
neurons = 160
patterns = np.stack((x1, x2, x3, x4, x5))
weightMatrix = hebbsRule(neurons, patterns)


# The distorted patterns
distortedPattern_1 = listToArray(
    [[1, 1, -1, -1, -1, -1, -1, -1, 1, 1], [1, 1, -1, -1, -1, -1, -1, -1, -1, 1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1],
     [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1],
     [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, 1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1]])

distortedPattern_2 = listToArray(
    [[1, 1, 1, -1, -1, 1, -1, 1, 1, -1], [1, 1, 1, -1, -1, 1, -1, 1, 1, -1], [1, 1, 1, -1, -1, 1, -1, 1, 1, -1],
     [1, 1, 1, -1, -1, 1, -1, 1, 1, -1], [1, 1, 1, -1, -1, 1, -1, 1, 1, -1], [1, 1, 1, -1, -1, 1, -1, 1, 1, -1],
     [1, 1, 1, -1, -1, 1, -1, 1, 1, -1], [1, 1, 1, 1, 1, -1, 1, 1, 1, -1], [1, 1, 1, 1, 1, -1, 1, 1, 1, -1],
     [1, -1, -1, -1, -1, 1, -1, 1, 1, -1], [1, -1, -1, -1, -1, 1, -1, 1, 1, -1], [1, -1, -1, -1, -1, 1, -1, 1, 1, -1],
     [1, -1, -1, -1, -1, 1, -1, 1, 1, -1], [1, -1, -1, -1, -1, 1, -1, 1, 1, -1], [1, -1, -1, -1, -1, 1, -1, 1, 1, -1],
     [1, -1, -1, -1, -1, 1, -1, 1, 1, -1]])

distortedPattern_3 = listToArray(
    [[1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1],
     [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1],
     [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1],
     [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1],
     [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1],
     [1, 1, 1, -1, -1, -1, -1, 1, 1, 1]])

distortedPatterns = np.stack((distortedPattern_1, distortedPattern_2, distortedPattern_3), axis=-1)

# Set the distorted pattern to the initial state of the neurons
dP = 0
sInitial = distortedPatterns[:, dP]

# Updating the McCulloch-Pitts Neurons with the asynchronous rule
numberOfIterations = 1
while True:
    numberOfIterations += 1
    sNext = np.copy(sInitial)
    for i in range(len(sNext)):
        dotProduct = weightMatrix[i, :].dot(sNext)
        localField = np.sign(dotProduct)

        if localField == 0:
            localField = 1
        else:
            sInitial[i] = localField

    if np.array_equal(sInitial, sNext):
        print('Steady pattern:', + np.resize(sInitial, (16, 10)))
        print('Steady state reached in:', + numberOfIterations, 'iterations')
        break

# Plotting the converged pattern
plt.title('Converged Pattern')
plt.imshow(np.resize(sInitial, (16, 10)), cmap='gray')
plt.show()